# 1. 面向对象

> 1. 面向对象(Object Oriented) 三大基本特征 - **封装(Encapsulation),继承(Inheritance),多态**(Polymorphism )
> 2. 面向对象不是一门技术 - 是一种思想,用来指导我们进行OOAD(面向对象分析和设计)和OOP(Object Oriented Programming面向对对象编程)

## 1. 面向过程

> C语言就是属于面向过程的.
>
> `面向过程 - 步骤化`
>
> 将问题找出每一步的解决方案 , 方案放入到函数中, 然后调用.
>
> 面向过程的世界中,程序 = 算法 + 数据结构.  优先考虑的就是具体怎么实现.

## 2. 面向对象

`核心思想 - 程序 = 对象,以"对象"为基本单位 - 符合人类思维的思想`

1. **找出业务中关键的"对象"**

   不如教务系统 - 教师,学生,班级,课程,选课,新闻,评论等等....

   淘宝 - 商品,用户,购物车,订单,商户,评价....

2. **分析对象的特征(属性)** - `对象拥有什么`

   比如以商品对象为例 - 价格,库存,销量,名称,封面url,详细描述等等...

3. **分析对象的行为(方法)** - `对象能干什么`

   以商品为例 - 有查询,修改,删除,增加等等功能.

4. **再分析出对象与对象之间的关系**

   自关联,1:1,1:N,N:N

5. 最后一步才是考虑具体怎么实现.

---

`面试题 - 用面向对象的思想来解释你现在看到的东西.`



# 2. 类和对象之间的关系

## 1. 什么是类

1. 类是构建对象的蓝图或者模板

   类是用描述对象的. 会将一些对象的共性抽象出"类别"出来.

2. 类是"抽象的概念" - 并不具体化

3. 类可以认为是一种数据类型.

`水果,交通工具`

## 2. 什么是对象

1. 对象叫做类的实例化或者具体化
2. 对象就是具体的概念 
3. 可以利用类来够构建对象的实例

`对象案例 - 苹果,香蕉`



`对象的作用 - 对象是数据在内存中的载体 - 把对象想象成存储数据的"容器"`

~~~java
Order o2 = new Order(1,"1001",600.0d);
~~~

# 3. 类的分类 - 实体类

实体类应该包含 - **属性,构造,getter/setter以及toString**,equals以及hashcode,clone

## 1. 属性

语法:

~~~java
修饰符 数据类型 [=初始值];
~~~

`如果没有手动赋值,系统根据数据类型会自动分配默认值`

---

`没有封装之前`

~~~java
public class Student {
    //没有进行封装 - 外部是可以直接操作这些数据的

    //属性 - 成员变量
    public int id = 1;

    //如果么有手动赋值,系统自动赋值
    public int age;

    public String name = "admin";

    public String[] hobbies = {"coding","sleeping"};
}
~~~

外部都是允许直接通过对象来操作这些数据的.

`弊端1`

~~~java
假设哪天属性名更改了,凡是外部使用到的地方都会受到影响 - 不利于后期的代码的维护.
~~~

`弊端2`

~~~java
1. 违背了面向对象的封装的特征. "封" - "装"
   保证的数据的安全,防止信息的泄露和任意的篡改[很容易造成数据的交叉感染]
  
2. 实体类中的属性并不是都是希望对外公开的.
  
3. 有时候,数据是需要进行校验的
  
4. 部分属性可能是由一段复杂的业务计算得到的.
   比如salary薪资
  
   e.salary = 3000.0d;
~~~

## 2. 对属性进行封装

`保证的数据的安全,防止信息的泄露和外部对数据的任意的篡改[很容易造成数据的交叉感染]`

如何对象属性进行封装

1. 属性私有化
2. 需要对允许外界操作的属性提供getter/setter

## 3. this关键字

1. 代表当前对象

   应用 - 成员方法形参名与成员属性名产生冲突的时候,可以使用this.属性来指明使用到的是成员属性
   
2. this关键字可以调用当前类已经存在的另外一个构造.但是this语句必须要出现在首行.

# 4. 构造方法constructor

语法:

1. 构造方法是通过new关键字调用
2. 构造方法的名称和类名是一致的,并且定义构造方法的时候,不需要写返回类型.
3. 构造方法是允许重载的.
4. 构造方法的分类 - 无参构造和带参构造
5. 如果某个实体类中没有提供任何的构造方法的时候,系统会默认分配一个空参构造.但是一旦手动提供了带参构造.那么系统将不会再分配空参构造
6. 带参构造同样也是可以对属性进行赋值

# 5. 构造方法和setter方法赋值区别

1. 构造方法是创建对象的同时对对象的属性进行赋值
2. setter方法是必须先创建好对象,然后才能进行赋值
3. 构造方法赋值的机会只有1次,但是setter方法是允许多次的.
4. setter方法是允许对数据进行校验的.构造方法实际上允许的,只是一般推荐写,但是允许在构造方法中去调用setter方法.
5. 构造方法的赋值方便一点.但是setter更加灵活.

---

# 6. toString方法

1. 打印对象,无论这对象是否显式调用toString,都是打印的toString的执行结果 - 打印对象 - 默认对象的toString方法

2. 如果本类中没有提供toString方法,会调用所有类的根类java.lang.Object中的toString方法

   ~~~java
   public String toString() {
     return getClass().getName() + "@" + Integer.toHexString(hashCode());
   }
   ~~~

3. 一般实体类需要手动提供toString方法 - 满足实际的打印需求. 一旦重写了toString - 就近原则.

---

