# 1. 方法的定义和使用

> 方法的定义: 用来完成一段特定代码的片段.  简单理解:就是写了一段逻辑代码,然后把这段代码放入到了方法中了.
>
> 因为这个方法是可以被其他地方调用的,并且调用者是无需关心这个方法内部的细节的 - 仅仅关心在这个方法的功能本身.
>
> 也是为了提高后期程序的可维护性.

## 1. 定义方法的语法

> ~~~java
> 定义方法的最全的语法:
> 修饰符 返回类型 方法名称([参数列表]) [throws 异常列表]{
>    方法体...
> }
> 
> 现阶段只需要
> 修饰符 返回类型 方法名称([参数列表]){
>    方法体...
> }
> ~~~

## 2. 语法解析

> 死记住 -
>
> 1. 方法体中绝对不允许定义方法.
>
> 2. main方法仍然是程序的主入口 - 必不可少.  因此需要在main方法在中调用自定义的方法.

1. 修饰符

    * 访问修饰符 - **public(公共的) private(私有的)** protected(受保护的) 默认的
    * 其他修饰符 - **static,**final,abstract

   修饰符之间是没有顺序的

2. 关于方法的返回类型有两大类

    1. 无返回类型 - void

       也是可以存在return语句

    2. 有返回类型 - 可以是八种基本数据类型或者对象类型[包括自定义对象类型] - String字符串

       方法体中一定含有**return + 返回值的语句;**

3. 方法名 - 命名的规范 - 请你参考变量名 - 小驼峰.
4. 参数列表
    1. 无参
    2. 固定长参数
    3. 可变长参数

## 3. 关于static关键字

有static修饰的方法 - 静态方法

没有static修饰的方法 - 非静态方法 - 普通方法

静态方法和非静态方法调用的方式是不一样的

***通用的规则:***

1. 非静态方法 - ①创建方法所在类的对象,②通过对象进行调用.

   非静态方法属于对象

2. 静态方法 - 允许直接使用类名.静态方法调用的

   静态方法属于类

总结: 属于谁,就由谁去调用!

---

`基于一定的原理之后可以使用的规则` - ***前提方法的定义和方法的调用在同一个类中.***

1. 非静态方法中是允许直接调用静态方法或者非静态方法.
2. 静态方法中是可以直接调用静态方法,但是不允许直接调用非静态方法.

---

## 4. 导包操作

> 类的全限定名 - 类的全称 - 包名.类名
>
> 一个包下的某个类调用另外一个包下的某个类中的方法的时候,必须先导包.
>
> ~~~java
> import tech.aistar.day02.method.MethodHelloDemo;
> 
> 不建议使用的 - 把method包下的所有的类都导入了 - 影响到性能.
> import tech.aistar.day02.method.*;
> ~~~

---

1. java.lang - java基础包 - 使用到该包下的所有的类,都是无需导包的.默认去到该包下搜索的.
2. java.util
3. java.sql
4. java.text
5. java.io

---

## 5. 私有方法的应用场景

> 1. 简化api - 方便程序的,减少对程序员的干扰
>
> 2. 场景
>
>    ~~~java
>    NB-Util类 - NB的方法 - 非常复杂的
>            
>    public static void nb01(){
>      //非常复杂的业务逻辑 - coding
>      //common...公开的重复的代码
>      commonNb();
>    }
>          
>    public static void nb02(){
>      //非常复杂的业务逻辑 - coding
>      //common - 公开的重复的代码
>      commonNb();
>    }
>          
>    //commonNb单独拿出用的话 - 到底有没有用.
>    //如果单独被调用,不会产生什么业务功能的话
>          
>    //"小螺丝的代码,不需要对外公开的代码 - 有必要定义成私有的"
>    private static void commonNb(){
>            
>    }
>    ~~~

---



# 2. 递归算法

> 使用解决大量的需要重复计算的业务.`和循环算法比较起来的话 - 递归算法性能是比较低下,需要保存中间的临时的值`

> 1. 递 - 将一个问题,分解成若干个子问题.并且发现这些子问题的解决过程是重复的/一样的.
> 2. 归 - 一定要指定一个递归的出口 - 临界值 - 不符合"递"的条件.

---

递归的步骤

1. 指定递归出口,如果没有指定递归出口,抛出java.lang.StackOverflowError
2. 方法体中调用自己.

---

练习:

1. **求*斐波那契*数列**

   **1 1 2 3 5 8 13 21 34 55 ...**

2. **求阶乘**

---

1. 求出俩个数的最大公约数 - 辗除法

2. 求杨辉三角坐标的数值

   ~~~java
   1
   1 1
   1 2 1
   1 3 3 1
   1 4 6 4 1
   1 5 10 10 5 1
   ~~~

5. 自闭题 - 给定一个数字,依次按照顺序输出这个数字每位上的数字

   比如1234, 直接输出1 2 3 4 => / %

   1234/10 = 123 / 10 = 12 / 10 = 1 % 10 = 1

   5 => 5%10=5

   ---

# 3. 方法的重载

> 简化api - 方便调用
>
> overload
>
> 发生的条件
>
> 1. 重载的方法是在同一个类中 - 存在于父子类关系中的.
>
> 2. 重载的方法的名称是相同的
>
> 3. 重载的方法的参数列表一定不同
>
>    3-1. 个数一样,类型不一样
>
>    3-2. 个数不一样
>
> 4. 重载的方法返回类型可以一样/不一样

---



# 4. java.lang.Math[C]

> 学习如何使用api学习手册 - 如何使用jdk中内置的类中的有用的方法.

> `Math`类包含执行基本数字运算的方法，如基本指数，对数，平方根和三角函数。

> 发现方法都是采用static修饰的,直接使用类名来调用.

> 常见的方法:max,min,abs,pow,sqrt,random
>
> 笔试:floor和round



# 5. 条件分支语句

1. if-else语句 - 比较灵活.
   * if语句可以单独使用.如果if块中只有一行代码,那么{}省略不写的.
   * if括号中只能是boolean值或者条件表达式,为true,则进入{}中执行
   * if和else , true=>if块,false=>else块,else块中如果只有一行代码,同样{}可以省略不写的.
   * if-else if - else if - else - 注意条件之间要互斥.
   * if或者else都是允许嵌套使用的.
2. switch-case语句
3. 三元操作符 - 三目运算符

---

# 6. 循环语句

## 1. for循环

for循环分类 - ***单层for循环***以及***嵌套for循环***,但是不推荐超过3层for,嵌套越多,性能越低.

1. 单层for循环语法

   ~~~java
   for循环的复合形态 - 不推荐使用 - 可读性比较差
   for(同时初始化俩个变量;表达式②;表达式③){
     //循环体...
   }
   ~~~

   ~~~java
   for(表达式①;表达式②;表达式③){
     //循环体
   }
   
   表达式① - 变量因子的初始化,比如int i = 0;
             只会走一次
               
   表达式② - 循环退出的条件,比如i<3;
             表达式②返回true,才会进入到循环体中去执行.否则,直接退出循环.
             至少走一次
               
             循环体走完,走表达式③
               
   表达式③ - 变量因子每次循环的变化; 比如,i++
             可能执行,可能不执行.
   ~~~

   `表达式省略的场景,常见的俩种`

   1. 表达式③省略了
   2. 三个表达式都省略了 - 死循环 - 循环体中必然会出现打破循环的语句.

2.  嵌套for循环

   ~~~java
   //外层for循环
   for(表达式①;表达式②;表达式③){
     //内层for循环 - 作为外部循环的循环体
     for(表达式③;表达式④;表达式⑤){
     	//循环体
   	}
   }
   外部循环执行一次,内层循环执行全部.
   ~~~



# 作业

> 1. 打印图形.
>
>    ~~~java
>    				*
>           * *
>          *   *
>         *     *
>        *       *
>         *     *
>          *   * 
>            *   
>    ~~~
>
> 2. 阶乘和斐波那契数列 - for循环实现一遍
>
> 3. 打印所有这样的组合,这个组合是三位数.  数字是由1,2,3,4当中的三个组成.
>
>    但是不能出现重复的数据.  比如合法的1,2,3   总共:24个
>
>    `增加难度:没打印6个换一行!`
>
> 4. 关于阶乘的题目
>
>    ~~~java
>    定义一个方法,传入一个参数,比如传入的是6.
>    程序最终输出的结果,必须是下面的:
>    1!=1
>    2!=2
>    3!=6
>    4!=24
>    5!=120
>    6!=720
>         
>    1! + 2! + 3! + 4! + 5! + 6!=873
>    ~~~

---



































