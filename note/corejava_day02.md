# 1. 类型转换

## 1. 自动类型转换

1. 小的数据类型可以自动转换成大的数据类型
2. 小的数据类型和大的数据类型在计算的时候,计算的结果是偏向类型大的一方
3. java中看到一个整数,默认是int类型,看到一个小数,默认是double
4. java中默认看到的数字都是属于十进制的数据

支持的转换常见的

byte->short->int->double

int->double

char->int

## 2. 强制类型转换

> 大的数据类型需要强制类型转换成小的数据类型
>
> 语法:    较小的数据类型   变量 = (较小的数据类型)大的数据类型变量/字面量

## 3. 隐式转换

> 1. 如何定义float,可以在double类型的数据后面加上f/F
>
>    double->float
>
> 2. 在int类型数据后面加上l/L,int转换成long类型.推荐L
>
> 3. 定义double类型,还是推荐在double后面加上d/D - 提高可读性

---

> 补充:俩个运算符也是可以进行内部的隐式转换的.+= ++ --

---

# 2. char类型介绍

java的char类型使用单引号表示,只能表示单个字符.char在java中是16位的,因为java用的是unicode编码

并且unicode编码是包含8为的ascii码,char类型在计算的时候使用的就是ascii.

虽然char和short类型都是占2个字节16bit,char保存的值更大一点,它是无符号的,没有负数.

char类型可以表示的范围是[0.65535]

面试:为什么char类型可以保存一个汉字,一个汉字在unicode下面占2个字节.

---



# 3. 转义字符

1. \b - 退格

2. 双引号和单引号分别是

   ~~~java
   \"  \'
   ~~~

3. \t - 制表符

4. \n - 换行,输出完毕之后,光标停在下一行的起始位置

5. \r - 回车,输出完毕之后,光标停在当前行的起始位置

---

`\b,\n,\r - 你在idea的伪终端和计算机的终端呈现的效果可能是不一样的!`



# 4. 进制换算

## 1. 二进制

> 由数字0,1组成.int类型表示的十进制的数据在计算机底层是采用32位的二进制数表示的.
>
> 逢2进一

---

> 1. 十进制转二进制
>
>    把十进制数不断除以2,直到商是0结束,倒过来取余数.
>
>    比如10 => 精简的二进制1010
>
> 2. 二进制转十进制
>
>    将二进制的每个位上的数字从左到右依次乘以2的次方[依次递减]
>
>    ~~~java
>    1011 => 1*2^3 + 0 + 1*2^1 + 1*2^0 = 11
>    ~~~

## 2. 八进制

> 由数字0,7组成,逢八进一.  定义int类型的时候,数字前面加0,表示的就是八进制
>
> 1. 二进制转换八进制
>
>    将二进制的数,从右到左,每三个一组.如果最高位不足3位,补0即可.
>
>    分别计算出每组对应的十进制的数
>
>    `为甚三个为一组,111->最大值是7`
>
>    001 010 101 010 111 => 012527
>
> 2. 八进制转换二进制
>
>    把八进制的每个数字转换成对应的三位的二进制
>
>    032 = 011 010
>
> 3. 十进制转八进制
>
>    把十进制数不断除以8,直到商是0结束,倒过来取余数.
>
>    26 = 032
>
> 4. 八进制转十进制
>
>    将八进制的每个位上的数字从左到右依次乘以8的次方[依次递减]
>
>    ~~~java
>    032 = 3*8^1 + 2*8^0 = 26
>    ~~~

## 3. 十六进制

> 数字0,9或者a~f/A-F组成,逢16进一
>
> 表示:0xf212   0x00b0
>
> 1. 二进制转十六进制
>
>    将二进制的数,从右到左,每四个一组.如果最高位不足4位,补0即可.
>
>    分别计算出每组对应的十进制的数.
>
>    1011 1110 1010 1111 1101 => 0xbeafd
>
> 2. 十六进制转二进制
>
>    把十六进制的每个数字转换成对应的四位的二进制

---



# 5. 运算符

## 1. 算术运算符

> ~~~java
> +   java中唯一重载的运算符.   纯数值之间表示加法计算,如果中间出现了字符串("")表示拼接
> -
> /   除法,    特殊的场景:取整(纯整数之间)
> %   取余/取模
> 
> /和%应用 - 给定一个数字,可以获取出每个位上的数字.
> 
> ++ 前++后++
> 
> -- 前--和后--
>   
> *
>   
> += -= /= %= *= 
>   
> = 赋值操作
> ~~~
>

## 2. 比较运算符

> ~~~java
> > < >= <= ==
> ~~~

## 3. 逻辑运算符

> ~~~java
> 逻辑非!  放在boolean表达式/boolean值前面
>   
> && 逻辑与/短路与 - 作用就是用来连接条件表达式/boolean值
>    短路的意思就是如果存在多个条件表达式,左边的结果已经能够决定整个结果的话,那么后面的表达式将不会执行.
>    所有的表达式都是true的时候,才会返回true
>   
>    注意: 将返回结果最有可能是false的条件表达式放在最左边
>      
> || 逻辑或/短路或 - 作用就是用来连接条件表达式/boolean值
>    短路的意思就是如果存在多个条件表达式,左边的结果已经能够决定整个结果的话,那么后面的表达式将不会执行.
>    只要存在一个true,结果就是true 
>      
>    注意: 将返回结果最有可能是true的条件表达式放在最左边
> ~~~

## 4. 位运算符

> 移位操作 - 移位操作是性能最高的运算
>
> ***面试题:请你用最高性能的方式计算出2的3次方.  2<<2***

> ~~~java
> >>  带符号的右移动,向右移动几位,就在最高位补符号位
> >>> 不带符号的右移动,向右移动几位,最高位补0
> << 左移动
>   
> ~ 按位取反
>   
> & 按位与/非短路与
>   作用1: 也是可以用来连接条件的.也是所有的条件表达式都是true,才会返回true.但是所有的表达式都会执行 - 一般不会推荐使用的.
>   作用2: 用来进行与运算的. 十进制值转换成二进制.在进行与运算的时候,每一个位置一一对应.都是1的时候,计算的结果才是1.
>         10 & 8 = 8
>         1 0 1 0
>         1 0 0 0
>        ----------
>         1 0 0 0
>    应用: 进行一个奇数和偶数的判断.
>      
> | 按位或/非短路或
>    作用1: 也是可以用来连接条件的.只要存在一个表达式为true,就返回true.但是所有的表达式都会执行 - 一般不会推荐使用的.
>    作用2: 用来进行或运算的. 十进制值转换成二进制.在进行与运算的时候,每一个位置一一对应.只要有一个1的时候,计算的结果就是1
>      
>    10 | 8 = 10
>    1 0 1 0
>    1 0 0 0 
>    -------
>    1 0 1 0
>      
> ^ 异或,相同为0,不同为1
>   10 ^ 8 = 2
>   1 0 1 0
>   1 0 0 0
>   -------
>   0 0 1 0
>      
>   10 ^ 8 ^ 8 = 10    结论: 一个数连续异或同一个数俩次,结果是它本身.   未来 - 简单的加密和解密的操作.
>   
>     0 0 1 0
>   ^ 1 0 0 0
>     -------
>     1 0 1 0 
>     
>    面试:交换俩个变量的值.
> ~~~

负数的二进制该如何计算? - 负数的二进制在计算机中是以补码的形式存在! - 为了计算机简化减法的操作的.

`注意:正数的原码,反码以及补码都是它本身`

符号位是32bit的二进制的最高位. 0 代表正数,1代表负数

反码 = 对原码进行按位取反[符号位不变]

补码的公式 = 反码 + 1



-10对应的原码 10000000 00000000 00000000 00001010

-10反码的反码 11111111 11111111 11111111 11110101

-10的补码                                                                              +1

​                           11111111 11111111 11111111 11110110

------------------------------------------------------------------------------------

`技巧的东西~9`							

9的二进制 00000000 00000000 00000000 00001001

~9的结果  11111111 11111111  11111111 11110110

~9 = -10,总结出***~x = -(x+1)***

---

-10 >>> 2

00111111111111111111111111111101 = 1073741821

---

-10>>2 = 负数十进制 = ~m

11111111111111111111111111111101 = ~2 = -3

00000000000000000000000000000010

---

`练习-15>>2和-15>>2`

---



# 6. 方法的定义和使用

> 方法的定义: 用来完成一段特定代码的片段.  简单理解:就是写了一段逻辑代码,然后把这段代码放入到了方法中了.
>
> 因为这个方法是可以被其他地方调用的,并且调用者是无需关心这个方法内部的细节的 - 仅仅关心在这个方法的功能本身.
>
> 也是为了提高后期程序的可维护性.

## 1. 定义方法的语法

> ~~~java
> 定义方法的最全的语法:
> 修饰符 返回类型 方法名称([参数列表]) [throws 异常列表]{
>    方法体...
> }
> 
> 现阶段只需要
> 修饰符 返回类型 方法名称([参数列表]){
>    方法体...
> }
> ~~~

## 2. 语法解析

> 死记住 - 
>
> 1. 方法体中绝对不允许定义方法.
>
> 2. main方法仍然是程序的主入口 - 必不可少.  因此需要在main方法在中调用自定义的方法.

1. 修饰符

   * 访问修饰符 - **public(公共的) private(私有的)** protected(受保护的) 默认的
   * 其他修饰符 - **static,**final,abstract

   修饰符之间是没有顺序的

2. 关于方法的返回类型有两大类

   1. 无返回类型 - void

      也是可以存在return语句

   2. 有返回类型 - 可以是八种基本数据类型或者对象类型[包括自定义对象类型] - String字符串

      方法体中一定含有**return + 返回值的语句;**

3. 方法名 - 命名的规范 - 请你参考变量名 - 小驼峰.
4. 参数列表
   1. 无参
   2. 固定长参数
   3. 可变长参数

## 3. 关于static关键字

有static修饰的方法 - 静态方法

没有static修饰的方法 - 非静态方法 - 普通方法

静态方法和非静态方法调用的方式是不一样的

***通用的规则:***

1. 非静态方法 - ①创建方法所在类的对象,②通过对象进行调用.

   非静态方法属于对象

2. 静态方法 - 允许直接使用类名.静态方法调用的

   静态方法属于类

总结: 属于谁,就由谁去调用!

---

`基于一定的原理之后可以使用的规则` - ***前提方法的定义和方法的调用在同一个类中.***

1. 非静态方法中是允许直接调用静态方法或者非静态方法.
2. 静态方法中是可以直接调用静态方法,但是不允许直接调用非静态方法.

---

## 4. 导包操作

> 类的全限定名 - 类的全称 - 包名.类名
>
> 一个包下的某个类调用另外一个包下的某个类中的方法的时候,必须先导包.
>
> ~~~java
> import tech.aistar.day02.method.MethodHelloDemo;
> 
> 不建议使用的 - 把method包下的所有的类都导入了 - 影响到性能.
> import tech.aistar.day02.method.*;
> ~~~

---

1. java.lang - java基础包 - 使用到该包下的所有的类,都是无需导包的.默认去到该包下搜索的.
2. java.util
3. java.sql
4. java.text
5. java.io

---











































