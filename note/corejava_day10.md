`OO有三大基本特征 - 封装,继承,多态,俩个高级特征 - 抽象和接口`

# 1. 抽象类

`抽象 - abstract修饰`

1. 什么是抽象类? - 不能够被实例化的类.**抽象类天生就是用来被子类继承的**.仍然是遵守java中类的单继承的特性.

2. 抽象类中可以有构造方法,普通属性,普通方法,可以拥有抽象方法.

3. 抽象方法 - 没有方法体的方法 - **天生就是用来被子类重写的.**

   **只有抽象类和接口才有资格去定义抽象方法.**

   ~~~java
   public abstract class Shape{
     public abstract double area();
   }
   ~~~

4. 如果一个非抽象的子类继承了抽象父类,那么这个子类必须要重写这个抽象父类中所有的抽象方法.

   除非这个子类也是一个抽象类.

---

## 匿名内部类

~~~java
SupAbstract father = new SupAbstract() {
  @Override
  public double area() {
    return 700;
  }

  @Override
  public double girth() {
    return 800;
  }
};
System.out.println(father.area());
~~~



# 2. 模板设计模式

> 应用场景:多个子类共有的方法且逻辑基本相同,可以把核心的算法和重要的功能设计为模板方法,子类去实现相关细节功能.系统在进行重构或者是功能优化的时候可以将子类重复的代码抽离到父类中.
>
> 在模板模式中,模板类定义了业务执行的方式("要做哪些事情")包括执行顺序(业务执行的步骤)
>
> JdbcTempate
>
> 1. 获取db连接
> 2. 可能查询的是user表,也有可能是其他表...    不同的表 - 对应的sql语句是不一样.
> 3. 关闭连接,释放资源

---



## 1. 优点

1. 通过把子类中不变的部分抽离到父类中,从而可以去除子类方法的重复代码,便于维护
2. 行为由父类控制,拓展和实现由子类负责-符合开闭原则

## 2. 缺点

1. 不同的业务实现需要不同的子类去实现,导致类的个数不断增加,使得系统更为庞大.

   `但是允许使用匿名内部类`

2. 普通的设计 - 父类中存放一般的属性和一般的方法.由子类去重写.调用子类重写之后的这些方法.

   模板的设计 - 行为以及行为执行的顺序都是由父类控制,调用父类的行为.  增加系统的复杂性.

   

# 3. 接口的定义和使用

0. 接口和抽象类都是属于抽象的数据类型 - 不能够被实例化.

1. 接口想象成是一个特殊的"抽象类",jdk后期对接口的语法的改造比较大 - 为了尽可能让接口可以替代抽象类使用.

2. 使用interface关键字来定义,最终还是会被编译成.class文件.

3. 接口是支持多继承的 - 一个接口允许有多个直接的父接口.

   无论是类还是接口,都是支持多重继承.  `多继承和多重继承`

4. 接口和类之间的关系 - 类是用implements关键字去实现一个接口 - "实现的关系"

   `一个类是允许实现多个接口的,多个接口之间用逗号隔开`

5. 一个普通的类(非抽象的类)如果实现了接口,必须要实现这个接口中所有的抽象的方法

   `除非这个实现类本身就是一个抽象的实现类`

6. **接口中的属性都是公开的静态的常量属性**,不允许有构造方法.

7. jdk8.0开始允许使用default关键字来定义普通方法,静态方法的,私有方法的

8. 接口中可以定义抽象方法 - jdk8.0之前的说法是 - **java中的方法都是抽象方法.**

9. 接口的命名推荐使用I开头或者able结尾.

---

## 1. 接口的分类

1. 常量接口 - 接口中只有常量属性 - 专门管理应用程序中所有的常量 - 方便维护.

   jdk5.0开始被枚举类型取代了.

2. 业务接口 - 只存放方法

3. 标记接口 - 什么都没有,只是作为类型判断instanceof,比如jdk内置的标记接口java.io.Serializable

3. 函数式接口 - jdk8.0开始的

## 2. 接口的优势

> 接口是一种"契约","标准",屏蔽底层的具体的细节/实现.
>
> QQ软件    =>    调用天气数据的api接口    =>   气象局数据中心
>
> 高德软件 =>    调用天气数据的api接口    =>   气象局数据中心

---

> 操作系统中 - 图标 - os提供给我们的接口
>
> 公司/店 - logo => 给客户提供的接口,比如KFC - 老头

# 4. 多态的应用

多态的应用 - 面向接口编程

1. 对象的编译时类型写成接口,对象的运行时类型写成实现类.
1. 方法的参数列表写成接口,调用方法时的实参可以写成实现类
1. 方法的返回类型写成接口,方法的执行结果可以是实现类.



# 5.  设计模式

## 1. 概念

设计模式（Design Pattern）**是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结**。

使用设计模式的目的：为了**代码可重用性**、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码**编写真正工程化**；设计模式是软件工程的基石脉络，如同大厦的结构一样。

项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，**每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案**，这也是设计模式能被广泛应用的原因。

---

总体来说设计模式分为三大类：

**创建型模式**，共五种：**工厂方法模式**、**抽象工厂模式**、**单例模式**、**建造者模式**、**原型模式**。

**结构型模式**，共七种：适配器模式、**装饰器模式**、**代理模式**、外观模式、桥接模式、组合模式、享元模式。

**行为型模式**，共十一种：策略模式、**模板方法模式**、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

**其实还有两类：并发型模式和线程池模式**

---



## 2. 七大设计原则

为什么要提倡“Design Pattern”呢？根本原因是为了代码复用，增加可维护性。那么怎么才能实现代码复用呢？开闭原则具有理想主义的色彩，它是面向对象设计的终极目标。***其他几条，则可以看做是开闭原则的实现方法。***

### 1. 单一职责原则

***简介:单一职责原则（Single Responsiblity Principle SRP）***

**接口或类只提供一种业务实现。**
单一职责原则宗旨是每个接口、类的功能，只能用来做专门的事，强调系统内业务职责唯一，避免职责扩散，做到业务统一管理.



### 2. 开闭原则

***简介:总原则:开闭原则（Open Close Principle）*** - 对内禁止修改,对外可进行拓展

**开闭原则就是说对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代 码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，**我们需要使用接口和抽象类等**



### 3. 里氏替换原则

***简介:里氏替换原则（Liskov Substitution Principle）***

里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，**任何基类可以出现的地方，子类一定可以出现**。 LSP 是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实 现抽象化的具体步骤的规范。**里氏替换原则中，子类对父类的方法尽量不要重写和重载**。**因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。**



**因为继承带来的侵入性，增加了耦合性，也降低了代码灵活性，父类修改代码，子类也会受到影响，此时就需要里氏替换原则。**

- 子类必须实现父类的抽象方法，***但不得重写（覆盖）父类的非抽象（已实现）方法***。
- 子类中可以增加自己特有的方法。
- ***当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。***
- 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。



### 4.  依赖倒置原则

***简介:依赖倒转原则（Dependence Inversion Principle）*** 

**这个是开闭原则的基础**，具体内容：**面向接口编程，依赖于抽象而不依赖于具体**。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。 



### 5. 接口隔离原则

***简介:接口隔离原则（Interface Segregation Principle***）

这个原则的意思是：**每个接口中不存在实现类用不到却必须实现的方法**，如果不然，就要将**[接口拆分]()**。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。



### 6. 迪米特原则

***简介:迪米特法则（最少知道原则）（Demeter Principle)***

就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装方法的内部，通过 public 方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。 最少知道原则的另一个表达方式是：***只与直接的朋友通信***。类之间只要有耦合关系，就叫朋友关系。***耦合分为依赖、关联、聚合、组合等***。***我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友***。***局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部 变量出现在类中。*** 

---



### 7.  合成复用原则

> ***简介:合成复用原则（Composite Reuse Principle)***
>
> 原则是尽量首先使用组合/聚合的方式，而不是使用继承。

---

从事需求分析师岗位 - UML - 统一建模语言 - 类图 - 表示类和类,类和接口,接口和接口之间的关系

(依赖<关联<聚合<组合)(泛化 - 继承,实现)

图示 - 依赖 - 虚线+箭头,关联 - 实线 + 箭头, 

**聚合 - 实线加空心菱形 - 整体和局部的关系,但是整体不负责局部的生命周期.**

**组合 - 实线加实心菱形 - 整体和局部的关系,但是整体要负责局部的生命周期**

继承 - 直线加空心三角形

实现 - 虚线加空心三角形

---



# 6. 作业布置

1. 定义一个类Book类

   id,isbn(图书编号),bookName(名称),price(价格),type(图书类别-String - "Java","Python","Mysql"),createDate(出版日期)

2. 指定业务接口 - IBookDao

   ~~~java
   public interface IBookDao{
     
     void save(Book b);//增加一个图书
     
     Book[] findAll();//查询所有的图书
     
     void delByIsbn(String isbn);//isbn唯一的,根据编号删除
     
     Book[] sortByPriceDesc();//根据价格降序排
     
     //统计每个类型的个数
     //Java 3,Python 5,Mysql 1
   }
   ~~~

   ~~~java
   public class BookDaoImpl implements IBookDao{
      // 模拟db
     private Book[] dbBook = new Book[10];
     
     //表示有效长度
     private int size;
     
     
     
   }
   ~~~

3. 单元测试 - BookDaoTest - main方法

4. 完成最终的界面功能

   1. 启动程序,控制台显示

      ~~~java
      ======图书管理系统======
      1. 保存图书
      2. 查询所有图书
      3. 根据编号删除图书
      4. 根据价格降序排
      5. 统计图书类别数量
      请输入:>
      ~~~

      ~~~java
      请输入:>1
      请输入图书id:>
      请输入图书编号:>
      请输入图书价格:>
      ....
      
      返回菜单 0  直接查询 2
      请输入:>
      ~~~

      ~~~java
      请输入:>3
      请输入删除的编号:>1001
      返回菜单 0  直接查询 2
      请输入:>
      ~~~

---

